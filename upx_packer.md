# upx packer分析

## 结构

压缩码可划分为若干组，每组由以下三部分组成

+ 一字节的压缩信息（姑且简称为zip info）
+ 若干字节的原码信息
+ [*可选*] 一字节的循环解码结束判别码组成

## zip info

每组的zip info是8位，在解压缩时把每组的zip info连贯在一起取位。按顺序依次储存：

+ 原码位
+ eax码位
+ ecx码位

## 寄存器使用

+ ebx: 储存zip info
+ eax: 偏移
+ ecx: 循环计数
+ esi: 压缩码起始地址
+ edi: 原码起始地址
+ edx: 基于edi的偏移地址

## 执行流程

### 准备阶段

1. pushad
2. esi存压缩码起始地址，edi存解压后的原码起始地址
3. edi压栈
4. ebp = -1

### 循环解码阶段

#### 移动源码阶段

从zip info里取一位

+ 如果是1，就从[esi]里移动一字节到[edi]
+ 如果是0，就跳出此阶段

#### 获取偏移阶段

1. eax = 1
2. [`j1`] 从zip info取1位，`eax <<= 1`，将所取值存在eax最右边
3. [`j2`] 再取1位
   + 如果是0就跳转至`j1`开始循环
   + 如果是1就检查是否取完一组zip info
     + 如果取完一组，就跳转至`j2`开始循环
     + 如果确实是1，就跳出此阶段
4. eax -= 3

+ 若原来的eax >= 3
  1. eax <<= 8
  2. al = byte ptr [esi++]
  3. eax = ~eax
     + 若eax == 0，跳出整个循环解码阶段
       > 结束条件：原来的eax低24位为0x10且[esi]所存的那一字节为0xFF。实际调试时得出原来的eax为0x01000002。
     + 若eax不为0，ebp = eax，至下一阶段。
+ 若eax原本小于3
  > 此时只有一种情况，即获取偏移阶段只取了1位，且所取的值是0
  + 至下一阶段

#### 获取循环次数阶段

1. ecx = 0
2. 从zip info取1位，`ecx <<= 1`，将所取值存在ecx最右边
3. 重复一次第一步

+ 若ecx为0（即上面两次所取值都为0）
  1. ecx++
  2. [`j3`] 从zip info取1位，`ecx <<= 1`，将所取值存在ecx最右边
  3. [`j4`] 再取1位
     + 如果是0就跳转至`j3`开始循环
     + 如果是1就检查是否取完一组zip info
       + 如果取完一组，就跳转至`j4`开始循环
       + 如果确实是1，ecx += 2，跳转至`j5`
+ 若ecx不为0：[`j5`] ecx += 1 + (ebp < 0xFFFFFF300)

#### 循环移动阶段

1. edx = edi + ebp

+ 若ebp > -4
  + 以ecx为计数，循环移动
  + byte ptr[edi++] = byte ptr[edx++]
  + 循环结束后跳转至移动源码阶段
+ 若ebp <= -4
  1. [`j6`] dword ptr[edi] = dword ptr[edx]
  2. edi += 4, edx += 4, ecx -= 4
  3. 判断ecx
     + 若ecx仍为正，跳转至`j6`开始循环
  4. edi += ecx
  5. 跳转至移动源码阶段
