***

Python的整除为向下取整。取余公式`x % y = x - ((x / y) * y)`，比如`10 % -3 = -2`。

***

| 进制 | 全称 | 类型简写 |
| :---: | :---: | :---: | 
| 二进制 | binary | 0b |
| 八进制 | octal | 0o |
| 十六进制 | hexdecimal | 0x |

***

内置运算函数：`pow()` `abs()` `round()`

> `round()`为四舍五入，正好为5时向偶数取整。
>
> 取整对应到的还有`math.ceil()`和`math.floor()`,分别对应向上取整和向下取整。
> > `-3.7 // 1`的值是4.0而`math.floor(-3.7)`的值是4。

***

在Unix系统终第一行加入`#!/usr/bin/env python`就可以直接执行`foo.py`。此时可以删除文件扩展名`.py`。

***

`repr('xxx')`等效于`r'xxx'`的值两端加上引号，其类型仍为`str`。两者末尾都不能以反斜杠结尾，否则会报错。

***

字符串行尾加上反斜杠会使**反斜杠**和**换行符**一起被转义,即忽略掉反斜杠和换行符。

***

表示Unicode字符串的三种方法：

+ `\u` 解析1字节或2字节
+ `\U` 解析4字节
+ `\N{cat}` 解析括号内的emoji

***

比之于直接使用`'xxx'.encode()`和`b'xxx'.decode()`更通用的处理方式是`bytes(s, encoding="utf-8")`和`str(s, encoding="utf-8")`。这样不论是处理二进制字符串还是普通字符串都不会出错。

***

`bytes`是不可变序列，如果需要可变则使用`bytearray`。需要注意的是修改`bytearrya`的某一项时需要使用`ord(b'x')`这样的语句取得二进制字符的十进制序号。

***

Python内置**容器**：

+ 序列：`列表`、`元组`、`字符串`
+ 映射：`字典`
+ 既不是序列也不是映射：`集合`

> 适用于所有序列的操作：索引、切片、相加、相乘、成员资格检查、迭代 *(iteration)*

***

较新版本python中可以实现用关键字`in`查询字符串子串。比如`"aaa" in "abcaaadef"`其结果为`True`

***

列表的切片替代操作：

若有`a = [1, 2, 3, 4]`, 则:

+ `a[1:2] = []`结果为`[1, 4]`
+ `a[1:1] = ["a", "b"]`结果为`[1, 'a', 'b', 2, 3, 4]`
+ `a[1:1] = "ab"`结果为`[1, 'a', 'b', 2, 3, 4]`
+ `a[1:1] = ["ab"]`结果为`[1, 'ab', 2, 3, 4]`
+ `a[1:2] = "ab"`结果为`[1, 'a', 'b', 3, 4]`

列表的切片替代不会改变该列表在内存中储存的地址。

***

拼接列表有两种方式：

1. 需要创建副本的拼接：
    ```
    a = [1, 2, 3]
    b = [4, 5, 6]
    a = a + b
    ```
2. 无需创建副本的拼接：
    ```Python
    # 一 列表自带的extend()方法
    a.extend(b)
    # 二 前述列表的切片替代操作
    a[len(a):] = b
    ```

***

格式化输出:

| 替换字段名 | 转换标志 | 冒号 | 填充字符 | 对齐方式 | 正号 | 对齐数 | 逗号分位符 | 小数位数 | 类型说明 |
|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|

> + **替换字段名**可以使用索引或用句点来获取属性和方法等。比如：
>     ```Python
>     >>> import math
>     >>> f"{math.pi}"
>         '3.141592653589793'
>     ```
> + **转换标志**包括`!s`、`!a`、`!u`，分别对应指定用`str`、`repr`、`ascii`进行转换。
> + **对齐方式**有`<`居左、`>`居右、`^`居中三种。此外可以在此位置使用`=`使符号和数字之间放置**填充字符**（若未指定**填充字符**则默认为空格）
> + **正号**可以使正数带正号。
> + 对于**小数位数**来说如果没有把**类型说明**指定为`f`，则会截断字符串取得对应的长度。比如：
>     ```Python
>     >>> from math import pi
>     >>> f"{pi!s:.3}"
>         '3.1'
>     >>> f"{pi:.3}"
>         '3.14'
>     >>> f"{pi:.3f}"
>         '3.142'
>     ```
> + **逗号分位符**在**对齐数**和**小数位数**之间
>    ```Python
>    >>> from math import pi
>    >>> "{:20,.2f}".format(pi*10000)
>        '           31,415.93'
>    ```

综合使用：

```Python
>>> improt math
>>> f"{math.pi*10000:@^+60,.3f}"
    '@@@@@@@@@@@@@@@@@@@@@@@@+31,415.927@@@@@@@@@@@@@@@@@@@@@@@@@'
>>> f"{math.pi*10000:@=+60,.3f}"
    '+@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@31,415.927'
```

***

迭代时可用到的内置函数：

+ 并行迭代：`zip()`
+ 迭代时获取索引：`enumerate()`
+ 反向迭代：`reversed()` （不影响原地址的可迭代对象）

***

`for...else`和`while...else`配对的代码块中，`else`代码块内的语句在循环体没有执行`break`语句时执行。

***

闭包（`nonlocal`关键字与`global`关键字对应，用于修改非全局的外部作用域变量; `globals()`和`locals()`内建函数分别用于输出全局变量和局部变量，以字典形式返回）

> `vars()`不带参的情况下与`locals()`作用相同，带参时返回参数（通常是类或类的实例）的属性和方法的字典。

```Python
def f1(a):
    def f2(b):
        print(locals())
        nonlocal a
        a=4
        print(locals())
        return a*b
    return f2

a = f1(3)
print(a(4))
```

执行结果：

```Python
{'b': 4, 'a': 3}
{'b': 4, 'a': 4}
16
```

***

python循环中不包含域的概念。比如：

```Python
l = []
for i in range(3):
    def f(x):
        return x * i
    l.append(f)
i = 9
print(l[0](5))
# 结果为45
```

修正方式是使用闭包：

```Python
l = []
for i in range(3):
    def f(i):
        def f2(x):
            return x * i
        return f2
    l.append(f(i))
i = 9
print(l[0](5))
# 结果为0
```

***

在类定义中对所有**以两个下划线起始**的名称都进行转换，转换为`_类名__原始名称`

***

`@property` 主要用到了__get__()这一魔术方法，将普通的类转变为描述符（descriptor）

***

`a, b = c, d`操作的原理是先暂存元组`(c, d)`，然后解包暂存的元组，将值从左至右依次赋值给`a`和`b`。因此若使用`a[i], a[a[i]] = a[a[i]], a[i]`互换`a[i]`和`a[a[i]]`两处的值，则会导致`a[i]`先被赋值，使得`a[a[i]]`索引出错。正确的写法是`a[a[i]], a[i] = a[i], a[a[i]]`。

比如：

```Python
>>> a=[1, 2, 3, 4, 5]
>>> a[a[1]], a[1] = a[1], a[a[1]]
>>> a
[1, 3, 2, 4, 5]
>>> a=[1, 2, 3, 4, 5]   
>>> a[1], a[a[1]] = a[a[1]], a[1]  
>>> a
[1, 3, 3, 2, 5]
```

***
